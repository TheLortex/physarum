#version 430

layout (local_size_x = 32) in;

float speed = 1;

struct Tracer {
    float x;
    float y;
    float angle;
};

layout (set = 0, binding = 0) readonly uniform Size { 
    uint h;
    uint w;
} size;

layout (set = 0, binding = 1) buffer State {
    Tracer v[];
} state;

layout (set = 0, binding = 2) readonly buffer ImageI {
    float v[];
 } image_input;

layout (set = 0, binding = 2) writeonly buffer ImageO {
    float v[];
 } image_output;


const float delta_capteur = 1.0;
const float distance_capteur = 10.0;

float get_sample(float x, float y, float angle) {
    float vx = x + sin(angle) * distance_capteur;
    float vy = y + cos(angle) * distance_capteur;
    return image_input.v[size.h * uint(vx) + uint(vy)];
}

void main() {
    // UPDATE 
    uint i = gl_GlobalInvocationID.x;
    Tracer t = state.v[i];
    t.x += sin(t.angle) * speed;
    t.y += cos(t.angle) * speed;

    if (t.x >= size.w - 1 || t.x < 0) {
        t.angle = 2. * 3.14 - t.angle;
        t.x += sin(t.angle) * speed;
    }
    if (t.y >= size.h - 1 || t.y < 0) {
        t.angle = 3.14 - t.angle;
        t.y += cos(t.angle) * speed;
    }

    float v_left   = get_sample(t.x, t.y, t.angle - delta_capteur);
    float v_center = get_sample(t.x, t.y, t.angle);
    float v_right  = get_sample(t.x, t.y, t.angle + delta_capteur);

    if (v_center > v_left && v_center > v_right) {
        // do nothing
    } else if (v_left > v_right) {
        // turn left
        t.angle    -= 0.1;
    } else {
        // turn right
        t.angle    += 0.1;
    }

    state.v[i] = t;

    image_output.v[size.h * uint(t.x) + uint(t.y)] = 1.0;
}
